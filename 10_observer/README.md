# observer

## 定义

定义对象间的一种一对多的依赖关系。当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并自动更新

![image-20230817144223306](https://cdn.jsdelivr.net/gh/zhecks/static_resources/images/202308171442307.png)

## 命名规范

* 观察者模式又被称为发布-订阅模式
* 目标接口的定义，建议在名称后面跟Subject
* 观察者接口的定义，建议在名称后面跟Observer
* 观察者接口的更新方法，建议名称为update，当然方法的参数可以根据需要定义，参数个数不限、参数类型不限

## 推模型和拉模型

1. 推模型

目标对象主动向观察者推送目标的详细信息，不管观察者是否需要，推送的信息通常是目标对象的全部或部分数据，相当于是在广播通信

2. 拉模型

目标对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到目标对象中获取，相当于时观察者从目标对象中拉去数据。一版这种模型的实现中，会把目标对象自身通过update方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了

## 优缺点

观察者模式具有以下优点

* 观察者模式实现了观察者和目标之间的抽象耦合

原本目标对象在状态发生改变的时候，需要直接调用所有的观察者对象，但是抽象处观察者接口以后，目标和观察者就只是在抽象层面上耦合了，也就是说目标只是指导观察者接口，并不知道具体的观察者的类，从而实现目标类和具体的观察者类之间解耦

* 观察者模式实现了动态联动

所谓联动，就是做一个操作会引起其他相关的操作。由于观察者模式对观察者支出额实行管理，那就可以在运行期间，通过动态地控制注册的观察者，来控制某个动态的联动范围，从而实现动态联动

* 观察者模式支持广播通信

由于目标发送通知给观察者时面向所有注册的观察者，所以每次目标通知的信息就要对所有注册的观察者进行广播。当然，也可以通过在目标上添加新的功能来限制广播的范围（ps：避免死循环）

观察者模式的缺点

* 可能会引起无所谓的操作

由于观察者模式每次都是广播通信，不管观察者需不需要，每个观察者都会被调用update方法
